# [java] ☕ Java 의 정석

---

## 6장. 객체지향 프로그래밍1

### 6.1 객체지향 언어

- 객체지향 이론의 기본 개념은 `실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다` 라는 것
- 1960년대 중반에 객체지향 이론이 처음으로 적용 된 `시뮬라` 라는 언어가 나왔다고 함
- `객체지향 언어의 주요 특징`
    - 코드의 재사용성이 높음
        - 새로운 코드를 작성 할 때 기존의 코드를 이용하여 쉽게 작성 할 수 있음
    - 코드의 관리가 용이
        - 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경 할 수 있음
    - 신뢰성이 높은 프로그래밍이 가능
        - 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드 불일치로 인한 오동작 방지
- 객체지향 개념을 학습 할 때 재사용성과 유지보수, 그리고 중복된 코드의 제거 세 가지 관점에서 보면 쉽게 이해 할 수 있다고 함!!!
- 일단 만들고 개선해도 좋음

### 6.2 클래스와 객체

- `클래스` 란 객체를 정의 해놓은 것
    - 또는 객체의 설계 또는 틀
- 클래스는 객체를 생성하기 위함
- 클래스로부터 객체가 만들어 지는 과정을 클래스의 `인스턴스화` 라고 함
- 객체는 속성과 기능, 두 종류의 구성 요소
    - 이를 멤버 라고 함
- 참조변수(그냥 흔히 말하는 변수)

### 6.3 변수와 메서드

- `변수 별 메모리 적재 시기`
    - 클래스 변수
        - `static`
        - 클래스가 메모리에 올라갈 때 메모리에 적재됨
    - 인스턴스 변수
        - 클래스 내에서 전역으로 선언된 변수
        - 인스턴스가 생성 될 때 메모리에 적재됨
    - 지역변수
        - 변수 선언문이 수행 될 때 메모리에 적재됨
- 메서드는 작업을 수행하는데 필요한 값만 넣고 원하는 결과를 얻으면 될 뿐이라 내부적으로 어떤 처리를 거치는지 전혀 몰라도 되기 때문에 메서드를 `블랙박스` 라고 표현하기도 함
- 모든 메서드는 return 이 있어야 함
    - void 의 경우 return 이 없어도 컴파일러가 `return;` 을 추가해준다고 함 ㄷㄷㄷㄷ
- `JVM 의 메모리 구조`
    - `메서드 영역`
        - JVM 이 읽어들이는 클래스 파일을 분석하여 클래스에 대한 정보를 저장
        - 클래스 변수도 저장함 당연함
        - 메모리 구조의 텍스트 영역에서 데이터 영역이라고 생각 하면 될까?
    - `힙`
        - 인스턴스가 생성되는 공간
        - 모든 인스턴스는 힙에서 생성됨
    - `호출스택(callstack 또는 execution stack)`
        - 메서드의 작업에 필요한 메모리 공간
        - 메서드 호출 시 호출 스택에 호출된 메서드를 위한 메모리가 할당, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수도)들과 연산의 중간 결과 등을 저장
        - 메서드 종료 시 할당된 메모리는 반환됨
- `호출 스택의 특징`
    - 메서드 호출 시 수행에 필요한 만큼의 메모리를 스택에 할당받음
    - 메서드 종료 시 사용했던 메모리를 반환하고 스택에서 제거
    - 호출스택 맨 위에 있는 메서드가 현재 실행 중인 메서드
    - 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드
    - 맨 아래에 있는 메서드가 제일 마지막에 반환됨
    - 추상적 자료구조인 스택이 이거구나!
    - `while` 문 같은거 잘못 작성하면 뻗는 이유 == 메서드가 안끝나서 계속 스택에 쌓여 있다가 스택에 더이상 공간이 없어서 그럼
        - 스택 오버플로우
- 자바는 메서드 호출 시 매개변수로 지정한 값을 매서드의 매개변수에 복사해서 넘겨줌
- 매개변수가 기본형이면 기본형 없이 복사
- 참조형 변수면 인스턴스의 주소가 복사
- 기본형은 읽기만 할 수 있음
    - `String` 클래스같은 immutable 인가?
- 참조형은 읽기&쓰기 가능
- 기본형 참조형 잘못 쓰면 대참사가 일어날수도
    - 참조형이 인스턴스의 주소, 즉 포인터 주소를 복사 받기 때문에 자칫하다가 매개변수를 조작하려다가 메모리에 저장된 값이 바뀌어 버릴 수 있음 ㅎㄷㄷㄷ
    - 웬만하면 안전빵으로 기본형을 써야 하지 않을까
- 참조형이란 포인터였다!
- 기본형 배열도 참조형
- `반환 타입이 참조형이라는 것은 메서드가 객체의 주소를 반환한다는 것`
- 인스턴스에서 클래스 변수를 사용 할 수 있는 이유 == 이미 클래스가 메모리에 올라갈 때 자동으로 생성 되었기 때문
- 클래스 메서드에서 인스턴스 변수를 사용 할 수 없는 이유 == 클래스 메서드의 메모리 적재 시기가 인스턴스 변수의 적재 시기보다 빠르기 때문에 클래스 메서드에서 인스턴스 변수를 알 수 없기 때문

### 6.4 오버로딩

- 한 클래스 내에 같은 이름의 메서드를 여러 개 정의 하는 것을 `메서드 오버로딩` 이라고 하고 간단하게 `오버로딩` 이라고 함
- 오버로딩은 매개변수로 구분
    - 이름만 다르면 오버로딩 조건에 성립하지 않음
        - 매개변수 타입이 달라야 함
    - 전부 같은데 반환형만 달라도 안됨
    - 매개변수가 각기 다른 형이지만 순서만 다르게 정의된 메서드는 오버로딩으로 침
- 가변 인자(변수에 ... 쓰는거)는 같은 타입의 매개변수의 갯수에 제한을 두지 않음
    - 가변인자는 매개변수의 맨 마지막에 선언
- 가변인자는 배열도 가능
    - 즉, 가변인자는 내부적으로는 배열로 동직
    - 가변인자가 선언된 메서드를 호출하면 배열이 새로 생성됨
    - 비효율적이므로 가급적 꼭 써야 할 곳이 아니라면 배열로 선언
- 웬만하면 가변인자가 있는 메서드는 오버로딩 하지 않아야
    - `new String[]` 으로 선언하지 않고 `{}` 에서 선언하면 String 배열이 아니라 String 이 여러개 나와서 모호한 호출 예외가 뜨는 것을 확인함

### 6.5 생성자(Constructor)

- 인스턴스 초기화 메서드
- 생성자는 리턴 값이 없다
- 생성자도 오버로딩 가능함
    - `NoArgsConstructor` `AllArgsConstructor` 이런거
- `new()` 가 인스턴스를 생성하는 것이지, 생성자가 인스턴스를 생성하지는 않음
    - 생성자는 그저 인스턴스 변수들의 초기화에 사용
- 원래 생성자를 필수로 정의해야 함
    - 그런데도 불구하고 생성자가 없어도 괜찮았던 이유는 컴파일러가 자동으로 기본 생성자를 추가해주기 때문
    - 기본 생성자는 비어있는 생성자
    - 그런데 생성자가 있다면 컴파일러는 생성자를 생성해주지 않음
- 생성자에서 다른 생성자를 호출 할 때 클래스 이름 대신 `this` 사용
- 한 생성자에서 다른 생성자를 호출 할 때에는 반드시 첫 줄에서만 호출 가능
    - `super()` 가 선언 위치에 따라 빨간줄이 그어진 이유!
- 생성자가 여러 개일 경우 다른 생성자로 초기화 시 `this()` 에 매개변수를 넣어서 초기화
- 인스턴스 멤버에게만 `this` 사용 가능
    - 당연함

### 6.6 변수의 초기화

- 멤버 변수(클래스 변수와 인스턴스 변수)와 배열의 초기화는 선택적이지만, 지역변수는 필수
- 기본형 변수는 기본값이 정해져있지만, 참조형 변수는 null 이 기본
- `초기화 블럭`
    - 클래스 초기화 블럭은 클래스 변수의 복잡한 초기화에 사용
    - 인스턴스 초기화 블럭은 인스턴스 변수의 복잡한 초기화에 사용
    - 클래스 선언 다음에 `static {}` 이나 `{}` 으로 정의된 익명 클래스들이 초기화 블럭임
- 초기화 블럭은 생성자가 인스턴스를 생성하기 이전에 실행
- `static` 초기화 블럭-`static` 메인 함수-인스턴스 초기화 블럭-생성자-메인 함수 순서로 실행
- `멤버 변수의 초기화 시기와 순서`
    - `클래스 변수`
        - 클래스가 처음 로딩 될 때 한 번
        - 기본값 → 명시적 초기화 → 클래스 초기화 블럭
    - `인스턴스 변수`
        - 클래스가 인스턴스화 될 때(인스턴스가 생성 될 때) 인스턴스별로 초기화
        - 기본값 → 명시적 초기화 → 인스턴스 초기화 블럭 → 생성자