# [CS] 👽 열혈C프로그래밍

---

## 5장. 상수와 기본 자료형

### 5.1 C언어가 제공하는 기본 자료형의 이해

- 자료형은 데이터를 표현하는 방법
- 사용 언어마다 정수 표현 범위가 달라질 수 있음
- 일반적으로 int가 다른 자료형 연산 속도에 비해 동일하거나 더 빠르므로 정말 일반적인 경우에는 가급적 int 만 사용하는 것으로
- 음성 데이터나 영상 데이터 같은 경우 데이터의 양이 많아 연산의 속도보단 데이터 크기를 줄이는 것이 더 중요한 것들에는 `char` 나 `short` 가 유용하다고 함
- 실수 자료형의 경우 `정밀도` 가 제일 중요함
    - ❓ 정밀도
        - 오차가 발생하지 않는 소수점 이하의 자릿수
    - ❓ 실수 자료형 별 소수점이하 정밀도
        - `float`
            - 소수점 6자리, 4바이트까지는 오차가 발생하지 않음을 보장
        - `double`
            - 소수점 15자리, 12바이트까지는 오차가 발생하지 않음을 보장
        - `long double`
            - 소수점 18자리, 12바이트까지는 오차가 발생하지 않음을 보장
        - 정수 자료형에서 `int` 를 보편적으로 사용하듯 실수형에서는 `double` 을 사용
- 정수형에 `unsigned` 선언을 추가하면 0 이상의 값만 표현, 이 때 양의 정수 방향으로 표현 범위가 두 배가 됨
    - 정수 표현 범위가 음수를 포함하기 때문에 `unsigned` 를 선언하면 양수로만 사용하게 되므로 음수의 범위가 양수에 적용되어 일반적으로 사용할 때에 비해 두 배의 양의 정수 표현이 가능해짐
    - MSB(최상위비트)도 데이터 크기를 표현하는데 사용
    - `char` 의 경우 다를 수 있음, 컴파일러 별로 일반 `char` 를 `unsigned char` 로 처리하는 경우가 있기 때문에 이 경우 `signed` 라고 명시해야 함

### 5.2 문자의 표현 방식과 문자를 위한 자료형

- 0부터 127까지 사용
- `char` 는 실질적으로 정수인 아스키코드를 저장하기 때문에 정수형이라고 하며 동시에 문자형이기도 함

### 5.3 상수에 대한 이해

- 변수의 상대적 개념
    - 변경 불가능한 데이터
    - 이름 있는 상수와 이름 없는 상수로 나뉨
    - 기본 자료형을 근거로 표현
- `리터럴 상수(이름 없는 상수)`

    ```c
    int main(String[] args) {
        int num = 30 + 40;
    }
    ```

    - 다음에서 `num` 은 변수
    - `30` 과 `40` 은 상수
    - CPU 에서 해당 연산을 처리 할 때 `num` 의 `70` 대입보다 `30 + 40` 을 더 먼저 처리하는데, 이 때 어떻게든 메모리에 각각의 값이 존재해야함
    - 이 연산에서 `70` 은 `num` 이라는 이름으로 메모리에 존재하게 되지만, `30` 과 `40` 은 변수가 아니라 정해진 이름이 없이 저장 되기 때문에 이름 없는 상수라고 함
    - 리터럴 혹은 리터럴 상수
- 리터럴 상수를 사용할 때 접미사로 어떤 자료형의 상수인지 지정해야 함
    - 이 때 접미사들은 대소문자를 구분하지 않음
- `심볼릭 상수(이름 있는 상수)`
    - `const` 를 사용하거나 매크로를 사용한 상수
    - 변수 선언과 같이 선언하면 되나 접두사로 `const` 키워드를 사용
    - 단, 변하지 않아야 하는 수 이기 때문에 `const` 를 사용한 심볼릭 상수는 선언과 동시에 값을 지정해야 함

### 5.4 자료형의 변환

- `자동 형 변환(묵시적 형 변환)`
    - 대입 연산자의 왼편과 오른편에 존재하는 두 피연산자의 자료형이 일치하지 않다면, 왼편에 있는 피연산자 대상으로 형변환이 자동으로 일어남

        ```c
        // int 형 정수 245 를 double 로 자동 형 변환
        double num = 245;
        ```

    - 실수형 데이터를 정수형으로 변환 할 때에는 `소수부의 손실` 이 일어나게됨

        ```c
        int num = 129;
        char ch = num3;

        // 출력
        00000000 00000000 00000000 10000001
        ```

        ```c
        double doub = 3.14;
        int num = doub;

        // 출력
        3
        ```

    - 4바이트를 사용하는 `int` 를 1바이트를 사용하는 `char` 로 변환하면 `상위 바이트의 손실` 이 발생하게 됨
    - 이 때 부호가 변경될 수 있는데, `10000001` 은 정수로 `-127` 을 표현하므로 주의해야 함
    - 데이터 표현 범위가 큰 자료형에서 좁은 자료형으로의 변환에서는 이처럼 데이터의 손실이 일어날 수 있으므로 주의해야 함
- `정수의 승격에 의한 자동 형 변환`
    - `int` 연산 속도가 빠르므로 `int` 보다 작은 자료형의 연산에서는 그에 대한 결과를 `int` 로 자동으로 변환하는 것
- `피연산자의 자료형 불일치로 발생하는 자동 형 변환`
    - 산술 연산 시 두 개의 피연산자의 자료형이 일치해야하나, 아닌 경우 피연산자간의 자료형 일치를 위해 자동 형 변환하는 것
    - 데이터 손실을 최소화 하는 방향으로 진행됨
    - 정수의 승격에 의해 이 경우 `char` 와 `short` 는 생략 된다고 함
    - 정수 자료형보다 실수 자료형이 무조건 앞서는 형태로 정의 되어 있음

        ```c
        // 산술연산에서의 행 변환 규칙
        int -> long -> long long -> float -> double -> long double
        ```

- `강제 형 변환(명시적 형 변환)`
    - 괄호 써서 변환하는거
    - 이걸 `형 변환 연산자(type casting operator` 라고 함