# [spring] 🍃 토비의 스프링

---

## 4장. 예외

### 4.1 사라진 SQLException

- `catch` 쓰면 예외 처리는 꼭 해주자
    - 로그만 찍는 예외 처리도 하지 말자
- `throws Exception` 도 그냥 쓰지 마라
- 시스템 에러(`java.lang.Error`) 패키지에 속한 예외는 어차피 코드로 잡지 못하는 오류이므로 처리 하지 말 것
    - e.g., `OutOfMemoryError` `ThreadDeath`
- `Exception` 클래스는 체크 예외와 언체크 예외로 구분
    - `체크 예외` 는 Exception 의 서브 클래스이면서 `RuntimeExcxeption` 을 상속 하지 않은 것 들
    - `언체크 예외` 는 `RuntimeException` 을 상속 받은 것
- 체크 예외가 발생할 수 있는 메소드를 사용할 경우 반드시 예외 처리 코드가 있어야 함
    - 컴파일 에러가 생기기 때문에 `throws` 로 던지거나 `catch` 에서 처리
- 언체크 오류는 컴파일 시점에 에러가 생기지는 않으므로 예외 처리가 강제 되지는 않음
- jdk 초기 버전에서는 체크 예외가 많았다고 함
- `예외 처리 방법`
    - `예외 복구`
        - 예외 상황을 파악하여 문제를 해결하여 정상 상태로 복귀
        - 기본 작업 흐름이 불가능 하다면, 다른 작업 흐름으로 자연스럽게 유도 하는 것
            - e.g., 로컬 파일을 읽을 때 해당 파일이 존재 하지 않을 시 클라이언트에게 해당 파일이 없으므로 다른 파일 이용을 안내
            - e.g., db 커넥션 시간이 지나 time out exception 이 발생 했을 때, catch 에서 일정 시간 대기 후 다시 연결 시도
    - `예외처리 회피`
        - `throws` 로 던지는거
        - 예외가 발생한 오브젝트가 아닌 해당 오브젝트를 호출한 오브젝트에게 책임을 전가 하는 것이므로, 호출한 객체어서 예외 처리를 해줘야 함
    - `예외 전환`
        - 회피와 같이 처리의 책임을 오브젝트가 하지는 않지만, 발생한 예외를 다시 적절한 예외로 전환하여 던짐
            - e.g., 사용자 db PK 를 중복된 값으로 삽입 할 때 `SQLException` 이 발생하는데, 이를 `DuplicatePkException` 등의 클래스를 정의하여 이 예외를 날림
        - 다른 방법으로는 예외를 처리하는 객체가 처리 하기 쉽게 래핑 하는 것
            - e.g., 체크 예외를 언체크 예외인 런타임 예외로 바꾸는 경우
            - `EJBException`
                - 런타임 예외를 상속받음
                - EJB 예외가 발생하면 시스템 예외로 인식하여 트랜잭션 롤백을 수행
- 애플리케이션 로직 상 예외 조건이 발견 되거나 발생 할 수 있는데, 이 때는 체크 예외를 적절하게 사용 하는 것도 괜찮
- 복구 불가능한 오류라면 빠르게 런타임 예외로 매핑시켜 날려야 불필요한  throws 선언이 들어가지 않을 수 있음
- 항상 복구할 수 없는 예외가 아니라면 일단 언체크 예외로
- 시스템 또는 외부의 예외 상황이 원인이 아니라, 애플리케이션 자체 로직에 의해 의도적으로 발생시킨, 반드시 catch 해서 조치해야만 하는 예외를 `애플리케이션 예외` 라고 함
- 대부분의 SQLException 은 복구가 불가능
    - 외부 요인에 의하거나 시스템 오류가 대부분이기 때문

### 4.2 예외 전환

- 자바가 JDBC 의 SQLException 을 만들 때 해당 예외에 포함 시킬 SQL 상태 코드를 정확하게 만들어주지 않았기 때문에, SQLException 만 보고 결과를 파악하는 코드를 작성 하는 것은 위험함
- 예외 전환 시 원본 예외를 중첩시키는 것이 좋음

    ```java
    catch (DuplicateKeyException e) {
        // 이렇게 예외 새로 넘길 때 인자로 예외를 같이 넘김
        throws new DuplicateUsersIdException(e);
    }
    ```

- 데이터 액세스 기술에 따라 같은 상황에서 발생한 예외임에도 예외 클래스는 달라짐
    - 즉, 사용하는 데이터 액세스 기술에 따라 예외 처리가 달라야함
- JPA, Hibernate 처럼 오브젝트/엔티티 단위로 정보를 업데이트 하는 경우 `낙관적인 락킹(Optimistic Locking)` 이 발생할 수 이ㅣㅆ음
    - 두 명 이상의 사용자가 동시에 조회하고 순차적으로 업데이트 할 때, 뒤늦게 업데이트 한 것이 먼저 업데이트 한 것을 덮어쓰지 않도록 막아주는데 쓸 수 있는 기능
- `assertThat` 의 `is` 는 오브젝트의 `equals` 동등 비교가 아니라 주어진 클래스의 인스턴스인지 검사 해주는 것