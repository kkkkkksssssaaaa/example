# [spring] 🍃 토비의 스프링

---

## 3장. 템플릿

### 3.1 다시 보는 초난감 DAO

- `템플릿` 이란 일정한 패턴으로 유지되는 특성을 가진부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜 효과적으로 활용하는 방법
- `close()` 메소드는 열린 것을 닫는다는 것도 있지만 리소스를 반환하는 것으로도 사용됨

### 3.2 변하는 것과 변하지 않는 것

- 코드의 분리와 재사용을 위해 디자인 패턴을 적용
- `전략 패턴`
    - 템플릿 메서드 패턴보다 유연하고 확장성이 뛰어남
    - 오브젝트를 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해 의존하도록 만드는 것
- `마이크로 DI`
    - DI 의 장점을 단순화하여 IoC 컨테이너의 도움 없이 코드 내에서 적용한 경우
    - 수동 DI 라고도 함
    - 전략 패턴에서 일어날 수 있음

### 3.3 JDBC 전략 패턴의 최적화

- 클래스  파일이 많아진다면 내부 클래스를 선언하는 것도 좋은 방법
- `중첩 클래스`
    - Nested Class
    - 독립적으로 오브젝트로 만들어 질 수 있는 정적 클래스와 자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있는 내부 클래스로 구분
    - 내부클래스는 다시 범위에 따라 세 가지로 구분됨
- ❓ 내부 클래스의 범위에 따른 분류
    - 선언된 위치에 따라 구분
    - `내부 클래스`
        - 멤버 필드처럼 오브젝트 레벨에 정의되는 멤버 클래스
    - `로컬 클래스`
        - 메소드 레벨에 정의되는 클래스
    - `익명 내부 클래스`
        - 이름을 갖고 있지 않고 로직 구현만 되는 클래스

### 3.4 컨텍스트와 DI

### 3.5 템플릿과 콜백

- `템플릿`
    - 전략 패턴에서의 템플릿이란 어떤 목적을 위해 미리 만들어둔 모양이 있는 틀
    - 템플릿 메소드 패턴은 고정된 틀의 로직을 가진 템플릿 메소드를 슈퍼 클래스에 두고, 바뀌는 부분을 서브클래스의 메소드에 두는 구조
- `콜백`
    - 실행 되는 것을 목적으로 다른 오브젝트의 메소드에 전달 되는 오브젝트
    - 파라미터로 전달되지만 값을 참조하기 위한 것이 아니라 특정 로직을 담은 메소드를 실행하기 위해 사용
    - 자바에선 메소드 자체를 파라미터로 전달할 수 없다고 함으로 메소드가 담긴 오브젝트를 전달, 이를 `functional object` 라고 함
- `템플릿/콜백` 의 특징은 여러 개의 메소드를 가진 일반적인 인터페이스를 사용 할 수 있는 전략 패턴의 전략과는 달리 보통 단일 메소드 인터페이스를 사용
- 템플릿의 작업 흐름 중 특정 기능을 위해 한 번 호출 되는 경우가 일반적이기 때문
- 콜백은 일반적으로 하나의 메소드를 가진 인터페이스를 구현안 익명 내부 클래스로 만들어짐
- 콜백 오브젝트가 내부 클래스로서 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조

```java
// 템플릿/콜백 패턴 예시
public interface Callback {
    String find(String arg);
}

public class Main {
    void main() {
        Callback callback = new Callback() {
            String find(String arg) {
                return "hello";
            }
        }

        callMethod(callback);
    }

    void callMethod(Callback callback) {
        System.out.println(callback);
    }
}
```

### 3.6 스프링의 JdbcTemplate

- 네거티브 테스트란 예외 상황에 대한 테스트
    - `get()` 이라는 메서드를 테스트 한다면, 얻고자 하는 대상의 길이가 0일 때, 없을 때 등 정상적이지 않은 상황에서 어떤 결과가 도출 되는 지 검증 하는 것

### 3.7 정리

- 예외 발생 가능성이 있거나 공유 리소스의 반환이 필요한 코드는 반드시 `try/catch/finally` 를 사용