# [spring] 🍃 토비의 스프링

---

## 1장. 오브젝트와 의존관계

## 1.1 초난감 DAO

- DAO
    - Data Access Object
- 자바 빈
    - 원래 비주얼 툴에서 조작 가능한 컴포넌트를 말한다고 함
    - 다음과 같은 두 가지 관례를 따라 만들어진 오브젝트를 가리킴
        - ❓ 자바빈을 생성하기 위한 두 가지 규칙
            - `디폴트 생성자`
                - 파라미터가 없는 기본 생성자를 갖고 있어야 함
                - 툴이나 프레임 워크에서 리플렉션을 이용해 오브젝트를 생성하는데 필요
            - `프로퍼티`
                - 자바 빈이 노출하는 이름을 가진 속성?
                - getter setter 로 수정할 수 있는 속성
- 리팩토링
    - 기존 코드를 `외부의 동작 방식에는 변화 없이 내부 구조를 변경해서 재구성 하는 작업`
- 접근 제어자(Access Modifier)
    - 클래스의 멤버들의 접근 권한
    - ❓ 자바의 접근 제어자
        - `private`
            - 해당 클래스 내에서만 접근 가능, 외부에서 접근 불가
        - `default`
            - 기본
            - 같은 패키지 내에서만 접근이 가능, 상속 여부와 상관 없이 다른 패키지라면 접근 불가
        - `protected`
            - 같은 패키지 내에서 접근 가능, 상속받은 외부 패키지의 클래스에서 접근이 가능
        - `public`
            - 모든 클래스, 패키지에서 접근 가능

## 1.2 DAO 의 분리

- 관심사의 분리(Separation of Concerns)
    - 프로그래밍 기초 개념 중 하나
    - 관심이 다른 것은 가능한 `따로 떨어져서 서로 영향을 주지 않도록`
    - 상속 구조를 통하여 성격이 다른 관심 사항을 분리하고, 서로 영향을 주지 않게 하는 것이 목표
- 디자인 패턴
    - 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용 할 수 있는 재사용 가능한 솔루션
- 템플릿 메소드 패턴
    - 스프링에서 애용되는 디자인 패턴이라고 함
    - 슈퍼클래스에서 기본적인 로직의 흐름(db 커넥션 가져오기, sql 생성, 실행 반환) 의 일부를 오버라이딩 가능한 `protected` 등으로 만들고 서브 클래스에서 필요에 맞게 구현해서 쓰는 디자인 패턴
    - 변하지 않는 기능을 슈퍼 클래스에서 정의하고 변할 수 있는 기능들은 서브 클래스에서 생성
    - 슈퍼클래스에서 디폴트 기능을 정의해두거나 비워두었다가 서브 클래스에서 선택적으로 오버라이드하여 사용할 수 있도록 만든 메서드를 훅(Hook) 메서드라고 함
- 팩토리 메소드 패턴
    - 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것
    - 슈퍼 클래스에서는 인터페이스의 정의만 내리고 모든 구현은 서브 클래스에서
    - 슈퍼클래스에서는 서브 클래스에서 구현할 메서드를 호출한 뒤 필요한 타입의 오브젝트를 가져와 사용, 주로 인터페이스 타입으로 오브젝트를 리턴함
    - 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의한 메서드를 `팩토리 메서드` 라고 하고, 이런 방식으로 오브젝트 생성 방법을 나머지 로직, 즉 슈퍼클래스의 기본 코드에서 독립시키는 패턴

## 1.3 DAO 의 확장

- 개방 폐쇄 원칙
    - 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
    - 높은 응집도와 낮은 결합도
        - 높은 응집도
            - 응집도가 높다는 것은 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중 되어 있다는 뜻
            - 불필요하거나 직접 관련이 없는 외부의 관심과 책임이 얽혀 있지 않으며, 하나의 공통 관심사는 한 클래스에 모여있음
        - 낮은 결합도
            - 높은 응집도보다 더 민감한 원칙
            - 관계를 유지하는데 꼭 필요한 최소한의 방법만 간접적으로 제공
- 객체 지향 설계 원칙(SOLID)
    - 가이드라인
    - 디자인 패턴이 특별한 상황에서 발생하는 문제에 대한 구체적인 솔루션이라면, 객체지향 설계 원칙은 일반적인 상황에서 적용 가능한 설계 기준
    - ❓ SOLID
        - `SRP(The Single Responsibility Principle)` : 단일 책임 원칙
        - `OCP(The Open Closed Principle)` : 개방 폐쇄 원칙
        - `LSP(The Liskov Substitution Principle)` : 리스코프 치환 원칙
        - `ISP(The Interface Segregation Principle)` : 인터페이스 분리 원칙
        - `DIP(The Dependency Inversion Principle` : 의존관계 역전 원칙
- 전략 패턴
    - 개방 폐쇄 원칙 실현에 가장 잘 맞음
    - 자신의 기능 맥락(context) 에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔 사용할 수 있는 패턴

### 1.4 제어의 역전(IoC)

- 여기선 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않음
    - 제어 권한을 다른 대상에게 위임
- ❓ 라이브러리와 프레임워크의 차이
    - 라이브러리는 애플리케이션의 흐름을 직접 제어
    - 동작 도중 필요한 기능이 있을 떄 능동적으로 라이브러리를 사용
    - 프레임워크는 애플리케이션 코드가 프레임 워크에 의해 사용
    - 프레임 워크 위에 개발한 클래스를 등록하고, 프레임 워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용
    - 프레임워크에는 반드시 제어의 역전 개념이 적용 되어 있어야 함

### 1.5 스프링의 IoC

- `ApplicationContext` 객체를 초기화하여 `@Configuration` 을 사용하는 스프링 빈을 사용함
- `빈`
    - 스프링이 IoC 방식으로 관리하는 오브젝트
- `빈 팩토리`
    - 스프링의 IoC 를 담당하는 핵심 컨테이너
    - 빈 등록/생성/조회 가능하게 하며 그 외의 관리
- `애플리케이션 컨텍스트`
    - 빈 팩토리를 확장한 IoC 컨테이너
    - 빈 팩토리의 기능에서 스프링이 제공하는 애플리 케이션 지원 기능까지도 모두 지원해줌
    - `IoC 컨테이너`
        - IoC 방식으로 빈을 관리한다는 의미

### 1.6 싱글톤 레지스트리와 오브젝트 스코프

- ❓ 싱글톤 패턴
    - 디자인 패턴 중 하나
    - 생성자가 여러 차례 호출 되더라도 실제로 생성되는 하나이며 최초 생성 이후 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴
    - 가장 많이 활용되지만 가장 많은 비판을 받으며 안티 패턴이라고 부르는 사람도 있다고 함
    - ❓ 싱글톤 패턴의 한계
- 스프링은 기본적으로 빈을 싱글톤으로 생성
- 오브젝트의 동일성과 동등성
    - 완전히 같은 오브젝트인가 == 동일성
        - `==`
    - 동일한 정보를 담고 있는가 == 동등성
        - `equals()`
- 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공하는데, 이 것이 `싱글톤 레지스트리`
    - 스프링 컨테이너 == 싱글톤 관리 컨테이너
- 싱글톤 레지스트리는 싱글톤 객체를 `static` 과 `private` 를 사용하지 않아도 싱글톤으로 활용하게 해줌
    - IoC 방식의 컨테이너를 사용하여
- stateless 방식으로 설계 되어야 하기 때문에 전역 변수 사용을 가급적 피하고 메소드 변수나 파라미터, 리턴 값을 적절하게 사용하여 상태를 남기지 않아야 함
    - read-only 속성의 객체는 상관 없을듯
- 스프링이 관리하는 오브젝트, 즉 빈의 생성, 존재, 적용되는 범위를 `스코프` 라고 함
- 빈의 기본 스코프는 싱글톤
- 경우에 따라 빈은 다른 스코프를 가질 수 있는데, 대표적으로 `프로토타입` 스코프, `요청` 스코프, `세션` 스코프가 있음
    - `프로토타입` 스코프란 컨테이너에 빈을 요청할 때 마다 새로운 오브젝트를 만들어주는 것
    - `요청` 스코프란 웹을 통해 새로운 HTTP 요청이 생길 때 마다 생성되는 것
    - `세션` 스코프란 웹 세션과 비슷

### 1.7 의존 관계 주입(DI)

- ❓ `DI` 란
    - 오브젝트 레퍼런스를 외부로부터 제공받아 이를 통해 여타 오브젝트와 다이내믹하게 의존 관계가 만들어지는 것
    - 의존 관계 설정
- 의존 관계에는 방향성이 존재함
- 의존 관계란 한 쪽의 변화가 다른 쪽에 영향을 주는 것
- ❓ 의존 관계 주입의 세 가지 조건
    - 클래스 모델이나 코드에는 런타임 시점의 의존 관계가 드러나지 않기 때문에 인터페이스에만 의존 되어야 함
    - 런타임 시점의 의존관계는 컨테이너나 팩토리같은 제 3의 존재가 결정
        - 관계 설정 책임을 가진 코드를 분리해서 만들어진 오브젝트
        - 전략 패턴에서 등장하는 클라이언트나 `factory` 와 같은 작업을 일반화하여 만들어진 스프링 애플리케이션 컨텍스트, 빈 팩토리, IoC 컨테이너 등
    - 의존 관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공해줌으로써 만들어짐
- 스프링 IoC 방법으로는 외부로부터의 주입이 아닌, 스스로 검색을 이용하기 때문에 `의존관계 검색(DL)` 이라는 것도 있음
    - 자신이 필요한 의존 오브젝트를 능동적으로 찾으나 어떤 클래스의 오브젝트를 이용할지는 결정하지 않음
    - 런타임 시 의존 관계를 맺은 오브젝트를 결정하는 것과 오브젝트의 생성 작업은 외부 컨테이너에게 IoC 로 맡기지만, 이를 가져올 때는 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법

        ```java
        // factory 를 이용한 생성자
        // ConnectionMaker 는 인터페이스이기 때문에 
        // UserDao 는 자신이 어떤 오브젝트를 사용하는지 미리 알 수 없음
        // DaoFactory 는 IoC 컨테이너
        private ConnectionMaker connectionMaker;

        public UserDao () {
            DaoFactory daoFactory = new DaoFactory();
            this.connectionMaker = daoFactory.connectionMaker();
        }

        // ----

        // 의존 관계 검색을 이용한 UserDao 생성자
        public UserDao() {
            AnnotationConfigApplicationContext context = 
                new AnnotationConfigApplicationContext(DaoFactory.class);

            this.connectionMaker = context.getBean("connectionMaker", ConnectionMaker.class);
        }
        ```

    - 대개 의존관계 주입 방식인 첫 번째 방식을 사용함
- 의존 관계 검색 방식에서는 검색하는 오브젝트는 자신이 스피링 빈일 필요가 없음
- DI 를 원하는 오브젝트는 먼저 자기 자신이 빈이어야 함
- 스프링이 제공하는 기능의 99퍼센트는 DI 의 혜택을 이용

### 1.8 XML 을 이용한 설정

- xml 설정은 `@Bean` 과 `@Configuration` 이 붙은 자바 클래스로 만든 설정과 내용이 동일

### 1.9 정리